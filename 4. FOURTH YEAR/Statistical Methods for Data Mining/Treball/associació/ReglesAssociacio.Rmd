---
title: "Assotiation Rules"
author: 'Laura Julià'
date: "November 23, 2018"
output: 
  html_document:
    toc: yes
---

```{r, include=FALSE}
#install.packages("arules")
library(arules)
```

# 1. Importació de la base de dades


```{r}
dd <- read.table("Booking_data_preprocessada.csv",header=T, sep=",");

dcat<-dd[,sapply(dd, is.factor)] # Selecció de les variables categòriques

dtrans<-as(dcat, "transactions")# Transformación a transacciones
```


# 2. Itemsets més freqüents

```{r}
foo<-function(x){length(levels(x))}
sum(sapply(dcat, foo)) # suma de les categories que hi ha en tots els factors de la base de dades.
```

En total hi ha 2018 nivells diferents entre les 12 variables categòriques que tenim a la bbdd.

I més concretament, en cada variable hi ha el següent nombre de nivells:

```{r}
library(knitr)
kable(rbind (Hotel_name=length(levels(dcat$Hotel_Name)), Hotel_country=length(levels(dcat$Hotel_Country)),Hotel_City = length(levels(dcat$Hotel_City)), Room_Type_Level =
length(levels(dcat$Room_Type_Level)), Guest_Type =
length(levels(dcat$Guest_Type)), Trip_Type =
length(levels(dcat$Trip_Type)), Review_Date =
length(levels(dcat$Review_Date)), Is_Hotel_Holiday = length(levels(dcat$Is_Hotel_Holiday)), Is_Reviewer_Holiday = length(levels(dcat$Is_Reviewer_Holiday)),Review_Is_Positive =length(levels(dcat$Review_Is_Positive)), Reviewer_Nationality =
length(levels(dcat$Reviewer_Nationality)), Submitted_from_Mobile =length(levels(dcat$Submitted_from_Mobile)), TOTAL = sum(sapply(dcat, foo))), caption= "Nombre de nivells per categoria")
```

## 2.1. Image de dtrans
```{r results='hide'}
dtrans
inspect(head(dtrans,10))
summary(dtrans)
dim(dtrans)
```

Els items o nivells més freqüents són:

- Is_Reviewer_Holiday=No
- Is_Hotel_Holiday=No
- Trip_Type=Leisure trip
- Room_Type_Level=Other
- Submitted_from_Mobile=Yes

A la base de dades hi ha 5000 observacions i, com hem dit abans, 2018 nivells. 
```{r}
image(dtrans)
```

**Interpretació del gràfic:**

Le línies amb menys espais en blanc (les més negres) són les categories que més cops s'han donat. 

Hi ha massa nivells, a la imatge no podem treure conclusions perquè no es veu res clar. Així que es faran alguns canvis a la base de dades `dcat`:

1. La variable `Hotel_name` té molts nivells tot ja que es tracta d'un "identificador", el nom dels hotels no ens és útil com a variable explicativa.

3. La variable `Review_Date`, que té tants nivells com dies diferents hagin fet la ressenya els clients, s'agruparà en anys:

Modifiquem la base de dades segons els canvis mencionats anteriorment:

```{r}
dcat$Review_Date_Year <- as.factor(substring(dcat$Review_Date,1,4)) # Deixem només l'any
# Eliminació de camps no necessaris
dcat$Review_Date <- NULL 
dcat$Hotel_Name <- NULL 
dtrans<-as(dcat, "transactions") # Transformació a transaccions
```

I ara ja podem tornar a mirar quins ítems són els més freqüents:

```{r results='hide'}
dtrans
summary(dtrans)
dim(dtrans)
```

Els items més freqüents són els mateixos que abans:

- Is_Reviewer_Holiday=No
- Is_Hotel_Holiday=No
- Trip_Type=Leisure trip
- Room_Type_Level=Other
- Submitted_from_Mobile=Yes

Ara, a la base de dades hi ha 5000 observacions i  166 nivells. Per tant s'ha aconseguit reduir molt el nombre d'items.

Vegem-ho gràficament, amb una mostra de 100 observacions:

```{r}
image(dtrans[sample(1:length(dtrans),100)])
```

En la gràfica s'observa com els items compresos entre el nombre 50 o 150, més o menys, són poc freqüents (es veuen pocs punts negres, poques repeticions). Sabent que el nombre de nivells per categoria que tenim en aquest nova base de dades és:

```{r echo=FALSE}
kable(cbind( "Nombre de categories"= rbind (Hotel_country=length(levels(dcat$Hotel_Country)),Hotel_City = length(levels(dcat$Hotel_City)), Room_Type_Level =
length(levels(dcat$Room_Type_Level)), Guest_Type =
length(levels(dcat$Guest_Type)), Trip_Type =
length(levels(dcat$Trip_Type)), Is_Hotel_Holiday = length(levels(dcat$Is_Hotel_Holiday)), Is_Reviewer_Holiday = length(levels(dcat$Is_Reviewer_Holiday)),Review_Is_Positive = length(levels(dcat$Review_Is_Positive)), Reviewer_Nationality =
length(levels(dcat$Reviewer_Nationality)), Submitted_from_Mobile = length(levels(dcat$Submitted_from_Mobile)), Review_date_year = length(levels(dcat$Review_Date_Year)), TOTAL = sum(sapply(dcat, foo))), "Acumulat"=c(6,14,21,26,32,34,36,38,161,163,166,"-")))
```

Podem accedir a quines són les categories més freqüents fent `levels(dcat$Factor[Nº de la categoria que es vol mirar])`.

Per exemple, veiem que les linies 4 i 10 són molt negres, mirem quines són:

- Com que el primer factor (`Hotel_country`) té 6 nivells, el nivell 4 serà la tercera categoria de la variable Hotel_country, que és:

```{r}
levels(dcat$Hotel_Country)[4]
```

- Per a mirar la categoria 10, veiem amb la taula de les categories acumulades que la 10 es correspon a una de les categories de la variable `Hotel_City` i, més concretament, a la `10-6=4`:

```{r}
levels(dcat$Hotel_City)[4]
```

Això es veu també quan fem: 

```{r}
summary(dtrans)
itemFrequencyPlot(dtrans, support=0.3, cex.names = 1, col= 'lightsteelblue')
```


## 2.2. Algorisme Eclat

Ara, s'utilitzarà un altre algorisme per a generar itemsets freqüents, el **Eclat** (*Equivalence Class Transformation*). Es mirarà el support de cada itemset, i s'agafaran els més alts.

**Support**
$$Support(X)=\frac{Frequency \quad occurrence\quad of\quad X}{|\tau|}$$
És la fracció de transaccions que contenen l'itemset X.

```{r warning=FALSE, results=FALSE}
eclatdtrans<-eclat(dtrans, parameter = list(support=0.4, minlen=1, maxlen=5))
```

```{r}
inspect(head(eclatdtrans,n=14, by="support"))
```

S'observen com a items molt freqüents alguns dels que s'han trobat abans:

- Is_Reviewer_Holiday=No
- Is_Hotel_Holiday=No
- Trip_Type=Leisure trip
- Room_Type_Level=Other
- Submitted_from_Mobile=Yes

Però ara, a més, trobem itemsets de dos elements:

-{Is_Hotel_Holiday=No,Is_Reviewer_Holiday=No}
-{Trip_Type=Leisure trip,Is_Reviewer_Holiday=No}
-{Trip_Type=Leisure trip,Is_Hotel_Holiday=No}

Ho veiem gràficament:

```{r}
library(arulesViz)
plot(eclatdtrans, method="graph")
```

Considerarem només els itemsets amb els supports més alts, els obtinguts abans:

```{r}
plot(head(eclatdtrans,n=14, by="support"), method="graph")
```

https://rdrr.io/rforge/arulesViz/man/plot.html

# 3. Regles d'Associació.

A continuació s'utilitzarà l'algorisme Apriori (tenint en compte la confiança i el lift) per tal de trobar regles d'associació en la nostra base de dades.

**Confidence**

$$Confidence(X \rightarrow Y)= \frac{Support(X \cup Y)}{Support(X)}$$

La confiança ens indica quants cops la regla $(X \rightarrow Y)$ ha resultat ser certa. Així doncs, una confiança alta indica una alta proporció de transaccions que contenen el item X que també conté Y.

Ho apliquem a la nostra base de dades:

```{r warning=FALSE, results=FALSE}
rulesdtrans <- apriori(dtrans, parameter = list(sup = 0.02, conf = 0.05,  maxlen=5))
```

```{r}
inspect(head(rulesdtrans,n=15, by="confidence"))
```

Observem que hi ha regles que són molt òbvies, aquelles en que es ja que relaciona una ciutat amb un país, ja que aquestes prediccions es poden fer molt fàcilment: si sabem la ciutat del hotel (`Hotel_City`) sempre podrem saber el país del Hotel (`Hotel_Country`).

Però, a més, es mostren altres regles interessants a comentar:

- {Reviewer_Nationality=United States of America } => {Is_Reviewer_Holiday=No}
- {Room_Type_Level=Family, Is_Reviewer_Holiday=No} => {Is_Hotel_Holiday=No} 

Com que la confiança per a aquestes regles és 1, això significa que sempre que una transacció conté `Reviewer_Nationality=United States of America`, la variable `Is_Reviewer_Holiday` ha estat **No**.


**Lift**

$$Lift(X \rightarrow Y)= \frac{Support(X \cup Y)}{Support(X)·Support(Y)}$$
L'elevació (*Lift*) mesura la relació entre el suport observat i esperat si els itemsets X i Y fossin independendts. Tres possibles resultats:

- **Lift = 1:** la probabilitat d'ocurrència de X i Y es independent (no hi ha regla d'associació)
- **Lift > 1:** hi ha cert grau de dependencia, per tant existeix una regla útil per a realitzar prediccions.
- **Lift < 1:** els ítems es substitueixen entre si, és a dir, quan apareix X en una transació no apareix Y i a l'inversa.

Així doncs, buscarem regles a priori ordenant-les segons el valor del lift per obtenir aquelles regles amb els lifts més alts.

```{r  warning=FALSE, results=FALSE}
rulesdtrans <- apriori(dtrans, parameter = list(sup = 0.01, conf = 0.05,  maxlen=5))
```

```{r}
inspect(head(rulesdtrans,n=15, by="lift"))
```

Totes les regles obtingudes mostren una forta associació entre els itemsets de l'esquerra i els de la dreta.



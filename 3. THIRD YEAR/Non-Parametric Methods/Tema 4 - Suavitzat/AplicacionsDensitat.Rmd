---
title: "Aplicacions Estimacions Densitat No Paramètrica"
author: "Mireia Vilardell"
date: "17 maig de 2018"
output: html_document
---



## Estimació de la variabilitat de la funció de densitat No Paramètrica

La realització de simulacions sobre la funció de densitat triada, ens permet veure com canvia el biaix i la variabilitat segons h ('bw')

```{r}
fsim<-function(param1=c(0,1), param2=c(3/2,1/3),p1=0.5){
u<-runif(1)
if(u<=p1){resul<-rnorm(1,mean=param1[1],sd=param1[2])}
else{resul<-rnorm(1,mean=param2[1],sd=param2[2])}
return(resul)  
}

ff<-fsim()
for(i in 1:9999){ff<-c(ff,fsim())}
ff<-matrix(ff,100,100)

#Calcul amb una finestra gran

kden<-function(sim=ff[,1], h=1, tipus="biweight"){
  x<-sim[order(sim)]  # necessito els punts endrecats per establir una banda per a cada punt
  ksy <- density(x,  bw = h, kernel = tipus)$y
  return(ksy)
} 



ksy<-apply(ff,2,kden)

      mf <- apply(ksy, 1, mean) 

      sf <- apply(ksy, 1, sd) 

      x <- ff[, 10] #agafa una qualsevol per tal de fer qqplot
    
     ksx <- density(x,  bw = 1, kernel = "biweight")$x

      plot(ksx, mf, ylim = c(0, 0.5), type = "l", xlab = "", ylab ="Density") 

      mS <- mf + 2 * sf 

      mI <- mf - 2 * sf 

      lines(ksx, mS, type = "l", lwd = 2) 

      lines(ksx, mI, type = "l", lwd = 2) 
      
      lines(ksx, ksy[,10], col=2)
      x.real<-seq(min(ksx),max(ksx),0.1)
      real.d<-0.5*dnorm(x.real, mean=0, sd=1)+0.5*dnorm(x.real,mean=3/2, sd=1/3)
      lines(x.real,real.d, type="l", col=4)

# Calcul amb una finestra petita

      ksy<-apply(ff,2,kden,h=0.25)

      mf <- apply(ksy, 1, mean) 

      sf <- apply(ksy, 1, sd) 

      x <- ff[, 10] #agafa una qualsevol per tal de fer qqplot
    
     ksx <- density(x,  bw = 0.25, kernel = "biweight")$x

      plot(ksx, mf, ylim = c(0, 0.5), type = "l", xlab = "", ylab ="Density") 

      mS <- mf + 2 * sf 

      mI <- mf - 2 * sf 

      lines(ksx, mS, type = "l", lwd = 2) 

      lines(ksx, mI, type = "l", lwd = 2) 
      
      lines(ksx, ksy[,10], col=2)
      lines(x.real,real.d, type="l", col=4)
      
```

## Els Bootstrap semi-parametric

 Una versió bootstrap del test d'independència basat en la raó de versemblances
 per les estimacions nucli de les densitats, generant remostres bootstrap
 a partir d'aquestes estimacions nucli.
 
 Treballarem amb el fitxer LawSchool. Obrim el fitxer
```{r}
 lawSchool <- read.csv("~/Mat_Classes_ProfMVilardell/2018/NoParametrica/Exercicis/Law_School.txt", sep="")
```      

```{r}
require(sm)
require(rgl)
require(rpanel)
      
```         

Com estimar la densitat amb sm?
```{r}
library(sm)
library(rgl)
library(rpanel)
sm.options(eval.grid=FALSE, display="none")
fLSAT<-sm.density(lawSchool$LSAT, eval.points=lawSchool$LSAT)
fGPA<-sm.density(lawSchool$GPA, eval.points=lawSchool$GPA)
```       
 Com simular una remostra bootstrap SEMIPARAMÈTRICA de lawSchool?

 Remostra d'LSAT partir de l'estimació nucli fLSAT:
 
 fLSAT correspon a la densitat de la suma de dues variables,
  - la primera amb distribució igual a la empírica associada a lawSchool$LSAT
  - la segona amb distribució normal de mitjana 0 i desviació típica igual a
     la "band width" h amb la qual s'ha obtingut fLSAT.
 
 
Per tant una remostra completa s'obtindria com:
```{r}
sample(lawSchool$LSAT, replace = TRUE) + rnorm(nrow(lawSchool), sd = fLSAT$h)

sample(lawSchool$GPA, replace = TRUE) + rnorm(nrow(lawSchool), sd = fGPA$h)

# Com que volem simular matrius de dades sota condicions d'independència
# (H0 certa) una remostra bootstrap completa es pot obtenir generant
# independentment cada columna:
cbind(
  sample(lawSchool$LSAT, replace = TRUE) + rnorm(nrow(lawSchool), sd = fLSAT$h),
  sample(lawSchool$GPA, replace = TRUE) + rnorm(nrow(lawSchool), sd = fGPA$h)
)

```

Funcions necessaries per poder executar el codi

```{r}
likStat = function(xy,
                   fxy = sm.density(xy, eval.points = xy)$estimate,
                   fx = sm.density(xy[,1], eval.points = xy[,1])$estimate,
                   fy = sm.density(xy[,2], eval.points = xy[,2])$estimate) 
{
  sum(log(fxy / (fx * fy))) / length(fxy)
}



```

```{r}
# Generació de 9999 remostres bootstrap i càlcul de l'estadístic sobre
# cadascuna:
nboot = 9999

x = lawSchool[,1]
y = lawSchool[,2]
n = nrow(lawSchool)
hLSAT = fLSAT$h
hGPA = fGPA$h

set.seed(123)
lik.boots = replicate(nboot,
{
  lawSchool.boot = 
    cbind(sample(x, replace = TRUE) + rnorm(n, sd = hLSAT), 
          sample(y, replace = TRUE) + rnorm(n, sd = hGPA))
  likStat(lawSchool.boot)
}
)

# p-valor del test bootstrap:
lik.obs = likStat(lawSchool, fx = fLSAT$estimate)
(sum(lik.boots >= lik.obs) + 1) / (nboot + 1)

```      


## Exercicis

### 1. utilitza l'ouptut de sm per realitzar els gràfics de variabilitat anteriors
### 2. Estudia quina combinació de kernel i amplada de banda és útil per estudiar les dades de faithful. Utilitza la funció density.

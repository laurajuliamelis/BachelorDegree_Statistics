### R code from vignette source 'Aspirina.rnw'
### Encoding: ISO8859-1

###################################################
### code chunk number 1: Aspirina.rnw:64-80
###################################################
abans = c(270, 150, 270, 420, 202, 255, 165, 220, 305, 210, 240, 300, 300, 70)
despres = c(525, 570, 190, 395, 370, 210, 490, 250, 360, 285, 630, 385, 195, 295)
dif = despres - abans
dif

# Valor de la mitjana sobre les diferències originals:
meanDif = mean(dif)
meanDif

# vector amb els valors absoluts de les diferències:
absDif = abs(dif)

# Aquesta funció calcula la mitjana de les diferències sobre una mostra
# permutada per files:
meanPerm = function(signs, absDiff) mean(signs * absDiff)
# 'signs' ha de ser un vector de valors -1 o +1 de la mateixa llargada que 'absDiff'


###################################################
### code chunk number 2: Aspirina.rnw:84-96
###################################################
# Enumeració de totes les permutacions possibles:
n = length(dif)
sgn = c(-1, +1)
signsTab = expand.grid(as.data.frame(matrix(rep(sgn, n), ncol = n)))
# Les primeres 10 files de 'signsTab':
signsTab[1:10,]

# Càlcul de la diferència de mitjanes per cada permutació possible:
dMeansPerm = apply(signsTab, 1, meanPerm, absDiff = absDif)

# p-valor exacte del test unilateral "desprès > abans":
sum(dMeansPerm >= meanDif) / nrow(signsTab)


###################################################
### code chunk number 3: Aspirina.rnw:107-119
###################################################
# Generació d'una permutació (segons la convenció amb els signes):
sample(sgn, size = n, replace = TRUE)

# Avaluació de la mitjana de les diferències sobre una permutació aleatòria:
meanPerm(sample(sgn, size = n, replace = TRUE), absDif) 

# Generació de nPerms permutacions aleatòries i càlcul de la mitjana de les
# diferències sobre cadascuna d'elles:
nPerms = 9999
dMeansPerm = replicate(nPerms, meanPerm(sample(sgn, size = n, replace = TRUE), absDif))
# Càlcul del p-valor aproximat pel test unilateral "desprès > abans":
(sum(dMeansPerm >= meanDif) + 1) / (nPerms + 1)


###################################################
### code chunk number 4: Aspirina.rnw:134-167
###################################################
# Funció que calcula el p-valor (exacte):
# (per raons de brevetat i senzillesa, solament vàlida pel contrast unilateral
# anterior)
pairedP.val = function(delta0, x, y, signsTable) {
  n = length(x)
  if (missing(signsTable))
    signsTable = expand.grid(as.data.frame(matrix(rep(c(-1,+1), n), ncol = n)))
  y = y - delta0
  dif = y - x
  meanDif = mean(dif)
  dMeansPerm = apply(signsTable, 1, meanPerm, absDiff = abs(dif))
  return(sum(dMeansPerm >= meanDif) / nrow(signsTab))
}

# Successives aproximacions:
deltas = seq(from = 0, to = 100, by = 10)
pvals = sapply(deltas, pairedP.val, x = abans, y = despres, signsTable = signsTab)
matrix(c(deltas, pvals), nrow = 2, byrow = TRUE)

deltas = seq(from = 40, to = 50, by = 1)
pvals = sapply(deltas, pairedP.val, x = abans, y = despres, signsTable = signsTab)
matrix(c(deltas, pvals), nrow = 2, byrow = TRUE)

deltas = seq(from = 44, to = 45, by = 0.1)
pvals = sapply(deltas, pairedP.val, x = abans, y = despres, signsTable = signsTab)
matrix(c(deltas, pvals), nrow = 2, byrow = TRUE)

deltas = seq(from = 44.1, to = 44.2, by = 0.01)
pvals = sapply(deltas, pairedP.val, x = abans, y = despres, signsTable = signsTab)
matrix(c(deltas, pvals), nrow = 2, byrow = TRUE)

# Extrem inferior de l'interval, finalment aproximat per interpolació:
approx(pvals, deltas, 0.05)$y


